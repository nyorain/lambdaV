\documentclass[letterpaper,12pt]{article}

\usepackage{amsmath,amssymb,graphicx,hyperref,enumerate,bussproofs,turnstile,listings}
\usepackage[dvipsnames]{xcolor}

\usepackage[paper=letterpaper,left=25mm,right=25mm,top=25mm,bottom=25mm]{geometry}
\usepackage{fancyhdr} %% for details on how this work, search-engine ``fancyhdr documentation''
\pagestyle{fancy}

\lhead{CPSC 539B: Compiler Theory} 
\chead{Project: $\lambda$V}
\rhead{Jan}
\cfoot{Page \thepage}
\renewcommand{\headrulewidth}{0.4pt}
\renewcommand{\footrulewidth}{0.4pt}

\lstset{ 
	basicstyle=\footnotesize,
	tabsize=2,
}

\begin{document}

\section{Source language: $\lambda$V}

The syntax of $\lambda$V is as simple as possible. Expressions
can be numbers, true or false, an identifier or a list (consisting of zero or
more expressions). There would be no advantage in encoding builtins such
as $+$, $func$ or $if$ into the syntax of the language. Those are simply
pre-defined identifiers. In practice, keeping the syntax this simple has 
the advantage that writing a parser and AST representation is extremely trivial.

\begin{align*}
	e &::= num \:|\: true \:|\: false \:|\: \textit{id} \:|\: (l) \\
	l &::= \varnothing \:|\: e\:l
\end{align*}

\section{Types in $\lambda$V}

$\tau ::= Num \:|\: 
	Bool \:|\: 
	Vec\{2, 3, 4\}\{f, b\} \:|\: 
	Mat\{2, 3, 4\}\{f, b\} \:|\: 
	Rec\:\tau \:|\: 
	PureRec$ \\

Num is a type for all numbers. We don't seperate between integers and floating
point numbers, we just assume all numbers to be floating-point for simplicity
and since GPUs are usually optimized for that anyways. For logical true and
false, we have Bool. Then, we have various Vector and Matrix types (with
dimensions 2, 3 or 4 and floating point ``f'' or boolean ``b'' elements).
We simplicity, we only allow square-sized matrices at the moment, other
ones are rarely needed in shaders anyways. 
The types $Rec \tau$ and $PureRec$ are helper types that
allow us to model the restriction we have to put on recursive functions
(namely: only tail-recursion is allowed).
To allow minimizing the number of rules and distinct cases, we will
write $Vec1{b,f}$ as synonym for $Bool$ or $Num$, respectively.

Our typing judegement has the following form: \\
\begin{center}
\fbox{\begin{minipage}{15em}
	\begin{equation*}
	R, A \vdash e : \tau
	\end{equation*}
\end{minipage}}
\end{center}

$R$ is a \textit{recursive context}, as explained below.
$A$ is a tuple of tuple of expressions, representing the current
stack of call arguments.
Both $R$ and $A$ are basically needed as workaround for not typing
functions while allowing them in almost any context (there are some
technical limitations discussed below).
A typing judgement means that $e$ is of type $\tau$ (in context $R$).
We also use $T, U$ as type metavariables.
[I guess this is fairly common but for tuples we write $((a_1 \dots), a_2)$
for $(a_1 \dots a_2)$, i.e. appending to a tuple].

\begin{prooftree}
	t-num
	\AxiomC{}
	\UnaryInfC{$R, \varnothing \vdash num : Num$}
\end{prooftree}

\begin{prooftree}
	t-true
	\AxiomC{}
	\UnaryInfC{$R, \varnothing \vdash true : Bool$}
\end{prooftree}

\begin{prooftree}
	t-false
	\AxiomC{}
	\UnaryInfC{$R, \varnothing \vdash false : Bool$}
\end{prooftree}

\begin{prooftree}
	t-if
	\AxiomC{$\varnothing, \varnothing \vdash e_1 : Bool$}
	\AxiomC{$R, A \vdash e_2 : tau_1$}
	\AxiomC{$R, A \vdash e_3 : tau_2$}
	\TrinaryInfC{$R, A \vdash (if\: e_1\: e_2\: e_3) : \text{rec-match}(tau_1, tau_2)$}
\end{prooftree}

\begin{prooftree}
	t-app
	\AxiomC{$R, (A, (e_1, \dots, e_n)) \vdash e_0 : \tau$}
	\UnaryInfC{$R, A \vdash (e_0\:e_1 \dots e_n) : \tau$}
\end{prooftree}

\begin{prooftree}
	t-func
	\AxiomC{$R, A_r \vdash e[e_1 / id_1]\dots[e_n / id_n] : \tau$}
	\UnaryInfC{$R, ((e_1 \dots e_n), A_r) \vdash (func\:(id_1 \dots id_n)\:e) : \tau$}
\end{prooftree}

\begin{prooftree}
	t-rec-func
	\AxiomC{$R, \varnothing \vdash e_i : \tau_i$}
	\AxiomC{$\overrightarrow{\tau_i}, A_r \vdash e[e_1 / id_1]\dots[e_n / id_n] : Rec\:\tau$}
	\BinaryInfC{$R, ((e_1 \dots e_n)) \vdash (\text{rec-func}\:(id_1 \dots id_n)\:e) : \tau$}
\end{prooftree}

\begin{prooftree}
	t-rec
	\AxiomC{$n > 0$}
	\AxiomC{$len(\tau_i) = n$}
	\AxiomC{$\varnothing, \varnothing \vdash e_i : \tau_i$}
	\TrinaryInfC{$\overrightarrow{\tau_i}, ((e_1 \dots e_n)) \vdash rec : PureRec$}
\end{prooftree}

\begin{prooftree}
	t-let
	\AxiomC{$R, A \vdash e[id_1 / e_1]\dots[id_n / e_n] : \tau$}
	\UnaryInfC{$R, A \vdash (let\:((id_1\:e_1)\dots(id_n\:e_n))\:e) : \tau$}
\end{prooftree}

The helper function \textit{rec-match} combines two different types in a recursive context.

\[
	rec-match(\tau_1, \tau_2) := 
	\begin{cases}
		\tau_1, & \text{for } \tau_1 = \tau_2, \\
		\tau_1, & \text{for } \tau_1 = Rec\:\tau_2, \\
		\tau_2, & \text{for } \tau_2 = Rec\:\tau_1, \\
		\tau_2, & \text{for } \tau_1 = PureRec \land \tau_2 = Rec\:T, \\
		\tau_1, & \text{for } \tau_2 = PureRec \land \tau_1 = Rec\: T, \\
		Rec\:T, &  \text{for } \tau_2 = PureRec \land \tau_1 = T \text{ (where T isn't $PureRec$ or $Rec\, U$)}, \\
		Rec\:T, &  \text{for } \tau_1 = PureRec \land \tau_2 = T \text{ (where T isn't $PureRec$ or $Rec\, U$)}
	\end{cases}
\]


Substituion is assumed to be context-sensitive (i.e. only substitute those
identifiers that are really meant in that case and not those that are
redefined in a deeper scope).

When typing expressions inside a \textit{rec-func} construct, the recursive 
context $R$ holds the types the \textit{rec-func} was called with. This means
that one cannot call recursive functions with function objects. In practice
this is a technical limitation we cannot overcome since SPIR-V does not support
dynamic dispatch and allowing recursion on arbitrary (possibly different
for each recursive call) functions yields cases where we can't inline
function calls anymore, i.e. can't unroll recursive functions to simple loops.
In practice, we could put a more relaxed restriction on our type system:
It is allowed to call recursive functions with function values as long
as all recursive calls use the same function value. Or even more general:
As long as there is only a finite number of functions used in the
recursive calls (meaning basically that you recurse with newly
instantianted functions in each recursion, it should be somewhat intuitive
that a case like that can't be inlined/unrolled anymore). But that
is a much more complicated restriction, yields a more complex type system
and code generation. And in practice one can simply use workarounds.
For instance:

\begin{lstlisting}
(let ((nat-fold (func (n accum f) (
	let ((body (rec-func (n accum) (
			if (eq n 0)
				accum
				(rec (- n 1) (f accum n))
		))))
		(body n accum)
)))) ... )
\end{lstlisting}

One can use function value parameters in recursive functions
by simply defining a non-recursive wrapper function.

The author did not know about the Curry paradox and functional
combinators (maybe he shouldn't have picked a functional source language)
and one can write recursive expressions like that in $\lambda$V as well.
Below is a (simpler) example showing how simple $func$ constructs can
be abused to get recursion.

\begin{lstlisting}
(let 
	((sumup (func (self n) 
		(if (eq n 0) 0 (+ n (self self (- n 1)))))))
	(sumup sumup 10))
\end{lstlisting}

But those expressions are not well-types. There is no derivation tree
for the well-typedness of the example expression since we define our
type rules by substituion, meaning that for recursive function constructs
like this one would need an infinitely large derivation tree.
In short: we expect programmers to play nice and use the \textit{rec-func}
construct we provide since we can't support arbitrary recursion. Sadly.

There are furtheremore a lot of more uninteresting typing rules for
the builtin primitives such as arithmetic or trigonometric functions.
We annotate those builtins with types (just some examples in the list below):

\begin{itemize}
	\item $Vecif \rightarrow Vecif$, e.g. the unary minus, fract, exp
	\item $Vecif \rightarrow Num$, e.g. length
	\item $Vecbf \rightarrow Bool$, e.g. anyOf
	\item $Vecif \times Vecif \rightarrow Vecif$, e.g. plus
	\item $Vecif \times Vecif \rightarrow Num$, e.g. distance
	\item $Vecif \times Vecif \rightarrow Vecbf$, e.g. lessThan or equal
\end{itemize}

Note that the generic $i$ must be the same for all parameters/return types.
This allows us to just give one generic rule for all of those builtins:

\begin{prooftree}
	\AxiomC{$builtin$ of type $(\tau_1 \dots \tau_n) \rightarrow \tau$}
	\AxiomC{$\varnothing, \varnothing \vdash e_i : \tau_i$}
	\BinaryInfC{$R, \varnothing \vdash (builtin\:e_1 \dots e_n) : \tau$}
\end{prooftree}


% $ioa$ (insert-or-assign) adds or overwrites a mapping in the $\Gamma$ function.
% \[
% 	ioa(\Gamma, id, e)(id_c) :=
% 	\begin{cases}
% 		e & \text{for } id = id_c \\
% 		\Gamma(id_c) & \text{otherwise}
% 	\end{cases}
% \]

\section{$\lambda$V operational semantics}

To reason about correctness properties of our translation, we will define
small-step operational semantics for $\lambda$V.

\begin{prooftree}
	\AxiomC{}
	\UnaryInfC{$\vdash (let\:((id_1\:e_1)\dots(id_n\:e_n))\:e) \rightarrow e[e_1 / id_1]\dots[e_n / id_n]$}
\end{prooftree}

\begin{prooftree}
	\AxiomC{}
	\UnaryInfC{$\vdash (if\:true\:e_2\:e_3) \rightarrow e_2$}
\end{prooftree}

\begin{prooftree}
	\AxiomC{}
	\UnaryInfC{$\vdash (if\:false\:e_2\:e_3) \rightarrow e_3$}
\end{prooftree}

\begin{prooftree}
	\AxiomC{}
	\UnaryInfC{$\vdash ((func\:(id_1 \dots id_n)\:e)\:e_1 \dots e_n) \rightarrow e[e_1 / id_1]\dots[e_n / id_n]$}
\end{prooftree}

\begin{prooftree}
	\AxiomC{}
	\UnaryInfC{$\vdash ((\text{rec-func}\:(id_1 \dots id_n)\:e)\:e_1 \dots e_n) \rightarrow e[e_1 / id_1]\dots[e_n / id_n][(\text{rec-func}\:(id_1 \dots id_n)\:e) / rec]$}
\end{prooftree}

The reduction rule for builtins are intuitively defined. Overflow is handled
by returning $\pm \infty$, operations on $\pm \infty$ or NaN lead to NaN.
Operations like division by zero or normalizing a zero-length vector give
undefined results. Basically, the semantics of all builtins are just
copied from SPIR-V.

\newcommand{\conv}{\rightarrow^+}
\newcommand{\red}{\rightarrow^*}

The conversion semantics are fairly simple due to our general list syntax:

\begin{prooftree}
	\AxiomC{$\vdash e \rightarrow e'$}
	\UnaryInfC{$\vdash e \conv e'$}
\end{prooftree}

\begin{prooftree}
	\AxiomC{$\vdash e_i \conv e_i'$}
	\UnaryInfC{$\vdash (\dots e_i \dots) \conv (\dots e_i' \dots)$}
\end{prooftree}

Reduction semantics:

\begin{prooftree}
	\AxiomC{}
	\UnaryInfC{$\vdash e \red e$}
\end{prooftree}

\begin{prooftree}
	\AxiomC{$\vdash e \conv e''$}
	\AxiomC{$\vdash e'' \red e'$}
	\BinaryInfC{$\vdash e \red e'$}
\end{prooftree}

\section{Translation}

We model translation as a recursive function \textit{translate}:

\begin{center}
\fbox{\begin{minipage}{15em}
	\begin{align*}
		(ce \times D \times R_i \times A \times ID) &\rightarrow (C \times ID \times ID \times I \times R_o) \\
		(expr \times defs \times r_i \times args \times id_i) &\mapsto (consts \times id_o \times id_t \times instructions \times r_o) \\
	\end{align*}
\end{minipage}}
\end{center}

\textit{ce} is simply the expression to be translated. We extend expressions
by an intermediate type generated during translation, an already translation
expression holding its ID, its type ID and its type.
$ce ::= e \:|\: genexpr(ID, ID, \tau)$

\textit{D} is a mapping from identifiers to expressions and their environment.
This is basically how we realize context-relative substitution in our
translation.

$R_i$ and $R_o$ are information needed to generate recursive
functions. $R_i$ is a tuple of header and continue block IDs for
the currrent recursive frame, as well as the type IDs of its parameters.
$R_o$ is a set of blocks and their respective parameter IDs for
recursvie calls (i.e. edges to the continue block).

\textit{A} models the current argument call stack, pretty much the same
way we modeled it for our typing rules.

\textit{ID} represents a SPIR-V ID. There are input and output to the 
translation function for the next usable id (e.g. if a translation of an
expression gets 42 as input, uses IDs 43, 44 and 45, it returns 46)
as well as an output for the type ID of the generated expression.

\textit{C} is a set of defined constant instructions. In SPIR-V constants
cannot be defined inline but have to be defined in a special section before
the start of the program, that's why keep them as a separate vector.

\textit{I} is the generated SPIR-V instruction vector.

\section{Correctness}

Basically, when $eval_\lambda(e) = o$ in $\lambda$V and 
$translate(e, \varnothing, \varnothing, \varnothing, 20) = (c, \_, \_, I, \varnothing)$,
then $eval_S(c, I) = o$

\end{document}

